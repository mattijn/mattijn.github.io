[
  {
    "objectID": "posts/2024-04-22-tegeltijdportaal/index.html",
    "href": "posts/2024-04-22-tegeltijdportaal/index.html",
    "title": "De 🌀 Tegeltijdportaal",
    "section": "",
    "text": "Binnen de tegeltijdportaal maken we het mogelijk om het tijdsverloop van elke locatie in Nederland te zien met zeer hoge resolutie satellietdata. Dit doen we door gebruik te maken van voorgerenderde tegels vanuit het satellietdataportaal. Hiermee krijg je snel inzicht in de dynamiek van locaties. In dit artikel duiken we dieper in op welke manier we deze informatie inzichtelijk maken.\nDit doen we in 2 stappen, namelijk:\n\nWat bedoelen we met een 🔲 Tegel definitie?\nHoe werkt de 🌀 Tegeltijdportaal?\n\n\nWat bedoelen we met een 🔲 Tegel definitie?\nDe nog altijd fascinerende tiendesprongen van Kees Boeke zijn je vast bekend sinds er in 1977 een film voor IBM werd gemaakt onder de naam Powers of Ten. \nHet laat een picknickend gezin zien in de haven van Chicago waar de camera steeds verder uitzoomt tot het hele universum te zien is, waarnaar het vervolgens weer inzoomt.\nWaar de film vooral gaat over het begrip van de machten van 10 en de relatieve verhoudingen tussen kosmisch en microscopisch niveau is, gaat het mij hier nu vooral over het concept dat je een bepaalde mate van detail ziet op een bepaald zoom niveau, ondanks dat het beeld wel een vaste afmeting heeft.\nDe satellietdata welke wordt ingekocht vanuit het satellietdataportaal heeft een hoge ruimtelijke resolutie. Recente opnames hebben bijvoorbeeld al een ruimtelijke resolutie van 30 centimeter. Om deze hele hoge resolutie fotos toegankelijker te maken gaan we de beelden net als de in de docu van de Power of Ten op delen in vaste zoomlevels. En op elk zoomlevel maken we tegels met vaste afmetingen. Op deze manier blijft een tegel altijd een vaste afmeting hebben, maar al naar gelang het gekozen zoomlevel zie je een hogere of lagere mate van detail.\n\nHet tegelschema of protocol WebMercatorQuad is zo’n manier om de aarde in kleine vierkante rasters of tegels te verdelen. Elke heeft een vaak een vaste afmeting van 256x256 pixels. En elk zoomlevel heeft daarmee zijn eigen vooraf gedefinieerde ruimtelijke resolutie. PDOK heeft de volgende tabel beschikbaar om hier iets meer duiding aan te geven:\n\nimport requests\nimport pandas as pd\nr = requests.get('https://api.pdok.nl/lv/bag/ogc/v1_0/tileMatrixSets/WebMercatorQuad?f=json')\npd.DataFrame.from_dict(r.json()['tileMatrices']).set_index('id')[15:21]\n\n\n\n\n\n\n\n\n\ntileWidth\ntileHeight\nmatrixWidth\nmatrixHeight\nscaleDenominator\ncellSize\npointOfOrigin\n\n\nid\n\n\n\n\n\n\n\n\n\n\n\n15\n256\n256\n32768\n32768\n17061.836671\n4.777314\n[-20037508.3427892, 20037508.3427892]\n\n\n16\n256\n256\n65536\n65536\n8530.918335\n2.388657\n[-20037508.3427892, 20037508.3427892]\n\n\n17\n256\n256\n131072\n131072\n4265.459168\n1.194329\n[-20037508.3427892, 20037508.3427892]\n\n\n18\n256\n256\n262144\n262144\n2132.729584\n0.597164\n[-20037508.3427892, 20037508.3427892]\n\n\n19\n256\n256\n524288\n524288\n1066.364792\n0.298582\n[-20037508.3427892, 20037508.3427892]\n\n\n20\n256\n256\n1048576\n1048576\n533.182396\n0.149291\n[-20037508.3427892, 20037508.3427892]\n\n\n\n\n\n\n\n\nIk heb hier enkel de rijen die overeenkomen met zoomlevels 15 tot en met 20 getoond. Het gaat mij vooral om kolom cellSize welke aangeeft wat de ruimtelijke resolutie is van een unieke pixel binnen elk zoomniveau. Hier valt bijvoorbeeld te zien dat op zoomlevel 17 de ruimtelijke resolutie van een enkele pixel ~1.19 meter is en zoomlevel 19 de ruimtelijke resolutie van een enkele pixel ~0.29 is.\nMeer info over deze 2 dimensionale tile matrix set standaard is ook te vinden via de website van OGC. En daarnaast deze video-presentatie van Jachym hoe je om kan gaan met grote hoeveelheden raster data via tegel definities met onder andere open source sofware.\nOm iets meer gevoel te krijgen met het effect van de zoom niveaus kan je de slider in het volgende figuur heen en weer bewegen. Het laat, gegeven een zoom level, zien hoe groot een tegel is voor het inliggende coordinaat van 🌍 Locatie HKV in Amersfoort.\n\nimport geopandas as gpd\nimport altair as alt\n\ngdf_tile = gpd.read_file('zoom_tegel_HKV_amersfoort.geo.json', driver='GeoJSON')\n# topologisch gesimplificeerd met https://github.com/mattijn/topojson\ngdf_prov = gpd.read_file('provincies_2023.simp.geo.json', driver='GeoJSON')\nxmin, ymin, xmax, ymax = gdf_prov.total_bounds\n\n# fit object should be a GeoJSON-like Feature or FeatureCollection\nextent_NL = {\"type\": \"Feature\", \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[xmax, ymax], [xmax, ymin], [xmin, ymin], [xmin, ymax], [xmax, ymax]]]}, \"properties\": {}}\n\nslider = alt.binding_range(min=8, max=17, step=1, name='zoom level')\nfilter = alt.param(bind=slider, value=8)\n\nchart = alt.layer(\n    alt.Chart(gdf_prov).mark_geoshape(filled=False),\n    alt.Chart().mark_circle(color='black').encode(\n        latitude=alt.datum(52.1515), \n        longitude=alt.datum(5.3790),\n        href=alt.value('https://www.hkv.nl')\n    ),\n    alt.Chart(gdf_tile).mark_geoshape(fill='orange', opacity=0.8).transform_filter(alt.datum.zoom_level == filter),\n    alt.Chart(gdf_tile).mark_geoshape(clip=True, filled=False, stroke='black', strokeWidth=1)\n).project(type='mercator', fit=extent_NL).add_params(filter)\nchart\n\n\n\n\n\n\n\nIn oranje zie je de daadwerkelijke tegel op het gekozen zoom nivea met het inliggende coordinaat van 🌍 Locatie HKV in Amersfoort en zwart omlijnt zie je de range aan tegels voor de verschillende zoom niveaus van deze coordinaat. Voor een kaart met geheel Nederland in beeld zijn de tegels vanaf level 16 niet meer zichtbaar op deze kaart. Om de inhoud van deze tegels te tonen zul je eerst verder moeten inzoomen op het interesse gebied.\nZoals je ziet volgen de tegels een vaste volgordelijkheid. Een specifieke locatie is daarmee altijd gekoppeld aan een eenzelfde tegel gegeven het zoom niveau. Zoals gezegd heeft de inhoud van elke tegel steeds een vaste afmeting. In ons geval is dit 256 x 256 pixels.\nBinnen het SBIR project met het thema biodiversiteit, subthema: natuur werken wij, vanuit het satellietataportaal, met tegels op 🔍 Zoomlevel 17. Deze tegels bevatten daarmee de data op het resolutie niveau die wij voor de gekozen toepassing toepasselijk vinden.\nAl met al is een gegeven 🔲 Tegel definitie dus een combinatie van een 🌍 Locatie en een 🔍 Zoomlevel.\n\n\nHoe werkt de 🌀 Tegeltijdportaal?\nNu we weten wat een 🔲 Tegel definitie is, laten we iets meer ingaan op welke manier we dit koppelen aan de services binnen het satellietdataportaal. We beginnen met een schematische weergave van de de applicatie, die we vervolgens in stapjes, met bijbehorende code uitwerken.\nDe applicatie werkt als volgt (voor simplificatie negeren we de quadkey als invoer):\n\n\n\n\n\ngraph TB\n    style invoer fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style tussenstap fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style uitvoer fill:#f0f0f0,stroke:#333,stroke-width:2px\n\n    style in1 fill:#ffff,stroke:#333,stroke-width:1px\n    style in2 fill:#ffff,stroke:#333,stroke-width:1px\n    style in3 fill:#ffff,stroke:#333,stroke-width:1px    \n    style in4 fill:#ffff,stroke:#333,stroke-width:1px\n    style int2 fill:#ffff,stroke:#333,stroke-width:1px    \n    style int3 fill:#ffff,stroke:#333,stroke-width:1px        \n    style out1 fill:#ffff,stroke:#333,stroke-width:1px\n\n    style int1 fill:#F8D664,stroke:#333,stroke-width:1px\n    style out2 fill:#F8D664,stroke:#333,stroke-width:1px\n\n    subgraph invoer\n\n        in1[\"🌍 Locatie\"]\n        in2[\"📏 Sensor resolutie\"]\n        in3[\"🔍 Zoomlevel\"]\n        in4[\"🎨 Kleuren composiet\"]  \n    \n    end\n   \n    subgraph tussenstap\n        \n        int1[\"⚙️ Index service satellietdataportaal\"]\n        int2[\"🔲 Tegel definitie\"]\n        int3[\"⏱️ Beschikbaarheid opnamen\"]\n        int4[\"📑 Collectie tegels\"]\n    end\n  \n    subgraph uitvoer\n        \n        out1[\"📊 Tegeltijdgrafiek\"]\n        out2[\"⚙️ Tegel service satellietdataportaal\"]\n    end\n    in1 --&gt; int1\n    in2 --&gt; int1\n    in3 --&gt; int2\n    in1 --&gt; int2    \n    in4 --&gt; int3\n    \n\n    int1 --&gt; int3\n    int2 --&gt; int3\n    int3 --&gt; int4    \n    int4 --&gt; out1\n\n    out1 --&gt; out2 --&gt; out1   \n\n\n\n\n\n\nLaten we beginnen met het bevragen van de ⚙️ Index service satellietdataportaal met de 🌍 Locatie en de 📏 Sensor resolutie input.\n\nimport requests\nimport geopandas as gpd\n\ndef index_service_satellietdataportaal(longitude, latitude, resolutions):\n    url = \"https://www.satellietdataportaal.nl/wp-admin/admin-ajax.php\"\n    \n    post_data = [\n        ('action', 'sdp_api'), \n        ('searchObject[geometry][type]', 'Point'),\n        ('searchObject[geometry][coordinates][]', longitude),\n        ('searchObject[geometry][coordinates][]', latitude)       \n    ]\n    for resolution in resolutions:\n        post_data.append(('searchObject[properties][filters][resolutionfilter][eq][]', resolution))\n\n    headers = {'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'}\n    r = requests.post(url=url, data=post_data, headers=headers)\n\n    feats = r.json()['data']['features']\n    if not feats:\n        return gpd.GeoDataFrame()    \n    gdf = gpd.GeoDataFrame.from_features(feats)\n    return gdf\n\nWe maken gebruik van een index_service_satellietdataportaal functie. Dit retourneert een geopandas GeoDataFrame gegeven een input op basis van longitude, latitude en gewenste resoluties. De 🌍 Locatie geven we op in decimale graden en de 📏 Sensor resolutie in meters.\n\nlongitude = 5.3790\nlatitude = 52.1515\n\nresolutions = [0.3, 0.5]\n\ngdf_layers = index_service_satellietdataportaal(longitude, latitude, resolutions)\ngdf_layers.head()\n\n\n\n\n\n\n\n\n\ngeometry\nacquisitiondate\nacquisitiontime\nid\nlayers\nresolution\nsensorname\n\n\n\n\n0\nPOLYGON ((5.22457 52.27334, 5.28787 52.27151, ...\n2024-01-28\n10:42:34\n20240128_104234_PNEO-03_1_1\n[{'composite': 'IRG', 'tile_link': 'https://ti...\n0.3\nPleiades-NEO\n\n\n1\nPOLYGON ((5.45336 52.26890, 5.45380 52.26890, ...\n2024-01-20\n10:38:07\n20240120_103807_PNEO-04_1_1\n[{'composite': 'RGB', 'tile_link': 'https://ti...\n0.3\nPleiades-NEO\n\n\n2\nPOLYGON ((5.44198 52.26726, 5.44268 52.26726, ...\n2024-01-18\n10:49:13\n20240118_104913_PNEO-03_1_1\n[{'composite': 'IRG', 'tile_link': 'https://ti...\n0.3\nPleiades-NEO\n\n\n3\nPOLYGON ((5.31342 52.16357, 5.50502 52.12998, ...\n2023-09-06\n11:14:14\n20230906_111414_SVNEO-01\n[{'composite': 'IRG', 'tile_link': 'https://ti...\n0.3\nSuperView-NEO\n\n\n4\nPOLYGON ((5.36459 52.27320, 5.55662 52.23953, ...\n2023-09-06\n11:14:12\n20230906_111412_SVNEO-01\n[{'composite': 'IRG', 'tile_link': 'https://ti...\n0.3\nSuperView-NEO\n\n\n\n\n\n\n\n\nZoals je kunt zien bevat dit informatie over de de datum en tijd van acquisitie, naam van de sensor en de resolutie die toebehoort tot de resolutie en bevat het een kolom met layers. Deze layers koppelen we aan onze gewenste tegel. De tegel definieren we met behulp van onze 🌍 Locatie en 🔍 Zoomlevel. We maken hierbij gebruik van de WebMercatorQuad tegelschema, zoals gezegd in de sectie over de 🔲 Tegel definitie.\nDaarnaast heeft het satellietdataportaal twee mogelijkheden voor een 🎨 Kleuren composiet. In ons geval maken wij gebruik van het vals kleuren composiet, waarbij we wel gebruiken maken van de nabij-infrarode band, rode band, en groene band, maar niet van de blauwe band. In het satellietdataportaal heet dit 🎨 Kleuren composiet IRG. Laten we onze opgevraagde layers verder opwerken om de gewenste 📑 Collectie tegels aan te maken.\n\ndef tile_collection(df, tile, composite):\n    if \"layers\" in df.columns:\n        df[\"tile_link\"] = [next((layer[\"tile_link\"] for layer in layers if layer[\"composite\"] == composite), None) for layers in df[\"layers\"]]\n        df[\"image\"] = [uri.format(z=tile.z, x=tile.x, y=f'{tile.y}.png') for uri in df[\"tile_link\"]]\n        df = df[[\"id\", \"acquisitiondate\", \"resolution\", \"sensorname\", \"image\", \"tile_link\"]]\n    return df\n\nWe maken gebruik van een tile_collection functie. Dit retourneert een pandas DataFrame gegeven de GeoDataFrame met layers, een 🔲 Tegel definitie, en het gewenste 🎨 Kleuren composiet.\n\nimport mercantile\n\ncomposite = 'IRG'\ntile = mercantile.tile(longitude, latitude, zoom=17)\ndf_tiles = tile_collection(gdf_layers, tile, composite)\ndf_tiles.head()\n\n\n\n\n\n\n\n\n\nid\nacquisitiondate\nresolution\nsensorname\nimage\ntile_link\n\n\n\n\n0\n20240128_104234_PNEO-03_1_1\n2024-01-28\n0.3\nPleiades-NEO\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\n\n\n1\n20240120_103807_PNEO-04_1_1\n2024-01-20\n0.3\nPleiades-NEO\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\n\n\n2\n20240118_104913_PNEO-03_1_1\n2024-01-18\n0.3\nPleiades-NEO\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\nhttps://tiles1.geoserve.eu/Pleiades-NEO_NRG/ti...\n\n\n3\n20230906_111414_SVNEO-01\n2023-09-06\n0.3\nSuperView-NEO\nhttps://tiles1.geoserve.eu/SuperView-NEO_NRG/t...\nhttps://tiles1.geoserve.eu/SuperView-NEO_NRG/t...\n\n\n4\n20230906_111412_SVNEO-01\n2023-09-06\n0.3\nSuperView-NEO\nhttps://tiles1.geoserve.eu/SuperView-NEO_NRG/t...\nhttps://tiles1.geoserve.eu/SuperView-NEO_NRG/t...\n\n\n\n\n\n\n\n\nOnze 📑 Collectie tegels in de vorm van een pandas DataFrame geven we weer met een Vega-Altair grafiek.\n\nhighlight = alt.selection_point(on='mouseover', empty=False, nearest=False, encodings=['x'])\n\nchart = alt.Chart(df_tiles, height=75, width=alt.Step(15)).mark_bar(\n    opacity=1, \n    strokeWidth=2, \n    cursor='pointer',\n    cornerRadius=15\n).encode(\n    x=alt.X('acquisitiondate:N').axis(formatType='time', format='%Y-%m-%d').title(None),\n    fill=alt.Fill('sensor_resolution:N').legend(orient='top').sort(field='resolution', op='max', order='ascending'),\n    stroke=alt.condition(highlight, alt.value('black'), alt.value('transparent')), \n    tooltip=alt.Tooltip(['image']),\n    order=alt.Order('resolution:Q'),\n).transform_calculate(\n    sensor_resolution=alt.datum.sensorname + \" (\" + alt.datum.resolution + \"m)\"\n).add_params(\n    highlight\n)\nchart\n\n\n\n\n\n\n\nOp de x-as zien we alle datums waarop een uniek satelliet-opname beschikbaar is van de locatie. De kleuren geven aan met welke satelliet-sensor de opname gemaakt is. Recentere opnamen hebben een hogere resolutie. Op dit moment koopt GeoServe namens NSO beelden in met een ruimtelijke resolutie van 0.3 meter van Pleiades-NEO, een satelliet-constellatie van Airbus.\nWanneer je met je muis over de staven heen beweegt licht er in de tooltip een afbeelding op van de tegel van de desbetreffende satelliet-opname. De afbeelding wordt on-the-fly opgehaald vanuit de ⚙️ Tegel service satellietdataportaal.\nOp deze manier is het mogelijk om met vaste tegelgrootte het tijdsverloop voor een locatie in Nederland gegeven het gewenste detailniveau.\nHandig wanneer je specifieke locaties in de gaten wilt houden op een bepaald verloop."
  },
  {
    "objectID": "posts/2024-01-22-stream-piano-midi-to-altair/index.html",
    "href": "posts/2024-01-22-stream-piano-midi-to-altair/index.html",
    "title": "Stream data from a piano to a Vega-Altair chart using MIDI",
    "section": "",
    "text": "I came to realise that playing a piano is a great example of streaming data. And since there is currently much activity around the JupyterChart object within Vega-Altair. Let’s see how far we can bring this combination into practice.\nLets start with a video of the final result\n\n\nWhoop! Whoop. It actually works. Lets break down what we see in the video.\n\nWe see a piano and a laptop.\nOnce I start playing the piano a histogram appears and updates.\n\nThe digital piano (kawai CA78) is connected with the laptop using an USB cable that streams musical information using the MIDI protocol.\nThe laptop presents a notebook within a JupyterLab environment. Within the notebook the video starts with an empty Vega-Altair bar chart. The chart is set-up to listen to the incoming stream of the musical information by the piano and once I start touching notes a histogram appears.\nOn the x-encoding channel we see all touched independent notes and on both the y-encoding channel and color-encoding channel we see the count() of the touched notes. This type of histogram is also known as a pianogram.\n\nHow does it work\nThe basis of the code is a Jupyter notebook written in Python. We listen to the incoming musical information using WEBMIDI.js. This is a package that performs as a Web MIDI API allowing a web page to interact with MIDI musical instruments. Since WEBMIDI.js is JavaScript we develop a custom Jupyter Widget using the AnyWidget package to make it accessible within our Python code. AnyWidget makes this possible by defining a shared state between JavaScript and Python through traitlets and loading the JavaScript code as an ECMA script module.\n\nimport altair as alt\nimport pandas as pd\n\nimport anywidget\nimport traitlets\n\nAnyMidi is the name of our class that will fuction as a Jupyter Widget:\n\nclass AnyMidi(anywidget.AnyWidget):\n    _esm = \"index.js\"\n\n    enabled = traitlets.Bool(default_value=False).tag(sync=True)\n    target_name = traitlets.Unicode(default_value=None, allow_none=True).tag(sync=True)\n    inputs = traitlets.List(allow_none=True).tag(sync=True)\n    noteon = traitlets.Dict(allow_none=True).tag(sync=True)\n    noteons = traitlets.List(allow_none=True).tag(sync=True)\n\nanym = AnyMidi()\n\nUsing the _esm parameter we refer to our JavaScript code as an ECMAScript module. Next, we define multipe traitlets. This are classes that functions as interchange objects between Python and JavaScript.\nOnce these variables are set within JavaScript, the corresponding variable in Python is updated. And vice-versa, if this variable is changed within Python, the variable is updated in JavaScript.\nOnce we call anym, it will initiate our Jupyter Widget and executes our JavaScript code. The code will enable the WebMidi.js package and collect information on available inputs.\n\nanym\n\n\n\n\n\n\nanym.enabled\n\nFalse\n\n\n\nanym.inputs\n\n[]\n\n\nBy default it add a listener to the first input device it detects target_name. The listener will update once a note on the musical instrument is played.\n\nanym.target_name\n\nSo if I play a note on the piano, information on of this note is captured and stored in the noteon attribute\n\nanym.noteon\n\n{}\n\n\nThe noteon attribute only provides information on the last played note, I also have configured another attribute named noteons. This attribute stores the last 100 played notes. This is a list that is empty by initiation and then upon playing the piano growing to a list of 100 elements and after that stays at a length of 100. The new notes are added and the oldest notes are removed using shifting.\n\nanym.noteons[0:3]\n\n[]\n\n\nNow that we have configured some traitlets that updates once I play the piano we can connect the stream to a JupyterChart class.\nWe define the following Vega-Altair specification with an empty DataFrame as input source:\n\ndf = pd.DataFrame.from_records([])\n\nbar_chart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('id:N'),\n    y='count():O',\n    color='count():O'\n)\n\nThis is a bar chart with on the x-encoding channel the field id, see anym.noteons above and observe that this refers to the field representing the tone identifier of the piano key. The y-encoding channel and color-encoding channel represent the count of the tone played.\nAs the input DataFrame is still empty the chart will look as follows:\n\nbar_chart\n\n\n\n\n\n\n\nAs we like to connect our piano stream to the chart, we need to know the name identifier of our dataset within the Altair specification. We extract the name as follows:\n\ndata_name = bar_chart.to_dict()['data']['name']\ndata_name\n\n'data-4f53cda18c2baa0c0354bb5f9a3ecbe5'\n\n\nThis is a hashed representation of the dataset upon initiating of the Altair specification. So even if I run the cell of bar_chart again, it will not change the identifier of our dataset within the Altair specification.\nTo update this dataset within the bar_chart to the piano stream I need to define it as an altair.JupyterChart. This makes it possible to update the chart after it is displayed.\n\njchart = alt.JupyterChart(bar_chart)\n\nNext up is the definition of a function that is called when there is a change observed for the anym.noteons attribute.\nSo this function is called every time a new piano key is pressed and the tone is added to the list of anym.noteons. The function change_noteons takes the anym.noteons and replaces the data variable defined within the jchart object.\n\n\n\n\n\n\nNote\n\n\n\nThis is currently using a non-public interface, jchart._py_to_js_updates, to update the JupyterChart object.\n\n\n\ndef change_noteons(change):\n    df = pd.DataFrame.from_records(anym.noteons)\n    jchart._py_to_js_updates = [{\n        \"namespace\": \"data\",\n        \"scope\": [],\n        \"name\": data_name,\n        \"value\": df.to_dict(\"records\")\n    }]\n\nanym.observe(change_noteons, \"noteons\")\n\nDone! Lets visualise our jchart visualisation and observe that the visualisation is updated when playing the piano.\n\njchart\n\n\n\n\n\nAwesome. That is fun. Before we continue. I forgot to explain one part. In our AnyMidi class definition is the line _esm = \"index.js\", this is in fact a referral to a file containing JavaScript code. For a better understanding I also will briefly go through this file. Some elements I will skip.\nThe file starts with the following\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\nThis is the import definition of the WebMidi JavaScript package that we use as an API to our connected piano using the MIDI protocol.\nThe other part that is important is the following:\nexport async function render({ model, el }) {\n    ...\n}\nThis defines a function with two objects. The model object and the el object. The model object makes it possible to store/set JavaScript variables that are approachable within Python using the traitlets objects.\nFor example the following code collects the different connected MIDI input devices and stores this in a inputsDict constant. Afterward this inputsDict dictionary is set on the inputs trait. We have to explicitly save the changes into model.\nconst inputsDict = WebMidi.inputs.map(input =&gt; ({\n    name: input.name,\n    manufacturer: input.manufacturer\n}));\n\nmodel.set(\"inputs\", inputsDict);\nmodel.save_changes();\nRemember the Python traitlet that synchronizes this data:\ninputs = traitlets.List(allow_none=True).tag(sync=True)\nThe following part is an example how the inpterplay between Python and JavaScript happens:\nBy default, the anym.target_name refers to the first detected name of the available inputs. But if you have multiple MIDI devices conncted you might want to switch the listener to a device of choice (I only have one device connected, so I cannot test if this actually works).\nSwitching is as simple as:\nanym.target_name = 'MY-OTHER-MIDI-DEVICE'\nWe need to listen for changes of the target_name. This is done as follows:\nmodel.on(\"change:target_name\", () =&gt; {\n    console.log('Target name changed');\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        registerListener(newTarget);\n    } \n});\nIf a change is detected in the target_name the JavaScript code will execute a function. In this function the newTarget is defined by getting the new target_name, through : const newTarget = model.get(\"target_name\") and then a new listener is registered to this newTarget.\nIf an error occurs in the JavaScript side of things we like to tunnel this back to our Python notebook. We use the el element for this. For example to define an innerHTML property that pipes back the ${error.message}:\nconst showError = error =&gt; {\n    el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n        &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n        &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n        &lt;/div&gt;`;\n};\nThe full index.js code can be seen by:\n\n\nClicking me\n\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\n\nlet activeInput = null;\n\nexport async function render({ model, el }) {\n    const showError = error =&gt; {\n        el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n            &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n            &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const showSuccess = () =&gt; {\n        el.innerHTML = `&lt;div style=\"color:green;\"&gt;\n            &lt;p&gt;WebMidi enabled!&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const collectInputsWhenEnabled = async () =&gt; {\n        try {\n            await WebMidi.enable();\n            if (WebMidi.enabled) {\n                console.log(\"WebMidi is enabled\");\n                console.log(WebMidi);\n\n                const inputsDict = WebMidi.inputs.map(input =&gt; ({\n                    name: input.name,\n                    manufacturer: input.manufacturer\n                }));\n                console.log(inputsDict);\n\n                model.set(\"inputs\", inputsDict);\n                model.save_changes();\n                console.log(\"WebMidi input saved in model\");\n\n                // Set target_name if it's not set already\n                if (!model.get(\"target_name\")) {\n                    const firstInput = WebMidi.inputs[0];\n                    if (firstInput) {\n                        model.set(\"target_name\", firstInput.name);\n                        model.save_changes();\n                    }\n                }\n            } else {\n                console.log(\"WebMidi is not yet seen as enabled\");\n                setTimeout(collectInputsWhenEnabled, 1000); \n            }\n        } catch (error) {\n            showError(error);\n        }\n    };\n\n    const registerListener = newTarget =&gt; {\n        // Remove listener from previous input, if exists\n        if (activeInput) {\n            console.log('Removing current active listener');\n            activeInput.removeListener();\n        }\n\n        activeInput = WebMidi.getInputByName(newTarget);\n        if (!activeInput) {\n            console.log('Setting none values');\n            // If activeInput is undefined, set noteons and noteon to empty or null\n            model.set(\"noteons\", []);\n            model.set(\"noteon\", null);\n            model.save_changes();\n            return;\n        }\n\n        const noteonsArray = [];\n        activeInput.addListener(\"noteon\", e =&gt; {\n            const noteonDict = {\n                id: e.note.identifier, \n                attack: e.note.attack,\n                ts: e.timestamp,\n                name: e.note.name,\n                octave: e.note.octave,\n                accidental: btoa(e.note.accidental)\n            };\n            console.log(noteonDict);\n            noteonsArray.push(noteonDict);\n            while (noteonsArray.length &gt; 100) {\n                noteonsArray.shift();\n            }\n            model.set(\"noteons\", noteonsArray);\n            model.set(\"noteon\", noteonDict);\n            model.save_changes();\n        });\n    };\n\n    try {\n        await collectInputsWhenEnabled();\n        model.set(\"enabled\", WebMidi.enabled);\n        model.save_changes();\n        showSuccess();\n    } catch (error) {\n        showError(error);\n    }\n\n    // Listen for changes to target_name and update the listener accordingly\n    model.on(\"change:target_name\", () =&gt; {\n        console.log('Target name changed');\n        const newTarget = model.get(\"target_name\") || null;\n        if (newTarget !== null) {\n            registerListener(newTarget);\n        } \n    });\n\n    // If target_name is already set, register the listener\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        console.log('Target name already set');\n        registerListener(newTarget);\n    } \n}\n\nLater more!"
  },
  {
    "objectID": "posts/2021-07-25-inpik-insight/index.html",
    "href": "posts/2021-07-25-inpik-insight/index.html",
    "title": "InpikInsight",
    "section": "",
    "text": "Meten is weten & tracken is ontdekken. Met sport data science krijg je inzicht in je performance, worden je kernkwaliteiten zichtbaar en kan je over tijd je progressie van houding en techniek onderbouwen.\nMet InpinkInsight is het mogelijk om jouw videobeelden van een wedstrijd of trainingssessie te analyseren. Wil je je eigen videobeelden door mij laten analyseren, of zie je andere mogelijkheden? Laat het me weten door een mail te sturen naar mattijn [at] gmail.com.\n\n\n\n\n\nWe zijn hier geinteresseerd in de positie van de pols ten opzichte van de schouder voor alle inpikken in de video. Deze zou met een juiste afstelling van de boot en een symmetrische haalbeweging gelijk moeten zijn voor links en rechts. Door wind, onrustig water en vermoeidheid is de verwachting dat deze positie niet gelijk blijft tijdens de gehele training. Deze service maakt het mogelijk om dit kwantitatief inzichtelijk te maken.\nHiervoor analyseren we de 30 minuten durende video (~54k frames, ~600 roeihalen) met Computer Vision en Machine Learning. We identificeren in elk frame de hoofdgewrichten en kijken voor elke inpik naar het hoogte verschil tussen de pols en schouder onafhankelijk voor links en rechts. In de animated gif hierboven zie je hoe dat gaat voor 2 halen.\nDe volgende Interactieve Graphic maakt de kwaliteit van inpikken kwantitatief inzichtelijk. Beweeg de slider om elke inpik an sich te analyseren.\n\n\nToon de code\nimport altair as alt\n\ndata_tracking = 'data_tracking.json'\ndata_stills = 'data_stills_base64.json'\n\n# updated to altair 5\nslider = alt.binding_range(min=0, max=576, step=1, name='Inpik ')\nselector = alt.selection_point(name='Inpik', value=1, bind=slider, fields=['nr'])\n\narea = alt.Chart(data_tracking, width=100).mark_area(\n    interpolate='cardinal',\n    opacity=0.7\n).encode(\n    color='var:N',\n    x=alt.X('value:Q').title(None),\n    y=alt.Y('bin_min:Q', bin='binned').title(None)\n).transform_bin(\n    as_=['bin_max', 'bin_min'], \n    field='val', \n    bin=alt.BinParams(maxbins=50)\n).transform_aggregate(\n    value='count()',\n    groupby=['var', 'bin_min', 'bin_max']\n)\n\ncircle = alt.Chart(data_tracking, width=100).mark_circle().encode(\n    color=alt.Color('var:N').legend(direction='horizontal', orient='top-left', padding=0).title(None),\n    x=alt.X('jitter:Q', stack='zero').scale(padding=10).axis(grid=False, labels=False, ticks=True, values=[0]),\n    y=alt.Y('val:Q').title(\"Positie pols tov schouder (schouder = 0)\").scale(padding=10),\n    opacity=alt.condition('datum.idx === Inpik_nr', alt.value(1), alt.value(0.2)),\n    size=alt.condition('datum.idx === Inpik_nr', alt.value(400), alt.value(40))\n\n).transform_calculate(\n    jitter=\"1*sqrt(-6*log(random()))*cos(2*PI*random())-8\"\n).add_params(selector)\n\nrule = alt.Chart().mark_rule(\n    color='#888888',\n    strokeDash=[10, 4]\n).encode(\n    y=alt.datum(0)\n)\n\nchart_top = (area + circle + rule).facet(\n    column=alt.Column('idx:Q', bin=True).header(labelPadding=-5).title(\"Inpik momenten (gegroepeerd per 100 slagen)\")\n)\n\nimage = alt.Chart(data_stills).mark_image(\n    height=200,\n    width=356,\n    x=356,\n    y=1\n).encode(\n    url='urls:N'\n).transform_filter(selector)\n\nalt.vconcat(\n    chart_top, \n    image\n).configure_view(\n    stroke=None\n).configure_axisY(\n    titleAlign='left', \n    titleAngle=0, \n    titleX=-10, \n    titleY=-10\n)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is my blog about data science projects. Most of my projects incorporate Vega-Altair specifications.\nI can be reached by email at mattijn [at] gmail.com"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mattijn.github.io",
    "section": "",
    "text": "De 🌀 Tegeltijdportaal\n\n\n\n\n\n\n\n\n\n\n\nApr 22, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nVerken de diversiteit van Nederlandse gemeenten\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nStream data from a piano to a Vega-Altair chart using MIDI\n\n\n\n\n\n\n\n\n\n\n\nJan 22, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nEngaging geovisualisations with Vega-Altair\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2023\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nInpikInsight\n\n\n\n\n\n\n\n\n\n\n\nJul 25, 2021\n\n\nMattijn van Hoek\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\nTalk presented at GeoPython 2023\n\n\nEncode spatial data as topology in Python! 🌍 https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivière (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel Östblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark’s color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\nTalk presented at GeoPython 2023\n\n\nEncode spatial data as topology in Python! 🌍 https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivière (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel Östblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark’s color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "href": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te creëren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda’s en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=350),\n    right_geom.properties(height=400, width=350),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  }
]