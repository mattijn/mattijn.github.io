[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mattijn.github.io",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\n\n\n\n\n\n\nVerken de diversiteit van Nederlandse gemeenten\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nStream data from a piano to a Vega-Altair chart using MIDI\n\n\n\n\n\n\n\n\n\n\n\nJan 22, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nEngaging geovisualisations with Vega-Altair\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2023\n\n\nMattijn van Hoek\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html",
    "href": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te creëren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda’s en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "href": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te creëren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda’s en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "href": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te creëren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda’s en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=350),\n    right_geom.properties(height=400, width=350),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/index.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "href": "posts/2024-01-26-CBS-nationaliteiten/index.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te creëren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda’s en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=350),\n    right_geom.properties(height=400, width=350),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\nTalk presented at GeoPython 2023\n\n\nEncode spatial data as topology in Python! 🌍 https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivière (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel Östblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark’s color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\nTalk presented at GeoPython 2023\n\n\nEncode spatial data as topology in Python! 🌍 https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivière (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel Östblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark’s color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair-geopython-2023",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair-geopython-2023",
    "title": "Engaging geovisualisations with Vega-Altair (GeoPython 2023)",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\n\n\nEncode spatial data as topology in Python! 🌍 https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivière (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel Östblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark’s color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet’s load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2024-01-22-stream-piano-midi-to-altair/index.html",
    "href": "posts/2024-01-22-stream-piano-midi-to-altair/index.html",
    "title": "Stream data from a piano to a Vega-Altair chart using MIDI",
    "section": "",
    "text": "I came to realise that playing a piano is a great example of streaming data. And since there is currently much activity around the JupyterChart object within Vega-Altair. Let’s see how far we can bring this combination into practice.\nLets start with a video of the final result\n\n\nWhoop! Whoop. It actually works. Lets break down what we see in the video.\n\nWe see a piano and a laptop.\nOnce I start playing the piano a histogram appears and updates.\n\nThe digital piano (kawai CA78) is connected with the laptop using an USB cable that streams musical information using the MIDI protocol.\nThe laptop presents a notebook within a JupyterLab environment. Within the notebook the video starts with an empty Vega-Altair bar chart. The chart is set-up to listen to the incoming stream of the musical information by the piano and once I start touching notes a histogram appears.\nOn the x-encoding channel we see all touched independent notes and on both the y-encoding channel and color-encoding channel we see the count() of the touched notes. This type of histogram is also known as a pianogram.\n\n\nThe basis of the code is a Jupyter notebook written in Python. We listen to the incoming musical information using WEBMIDI.js. This is a package that performs as a Web MIDI API allowing a web page to interact with MIDI musical instruments. Since WEBMIDI.js is JavaScript we develop a custom Jupyter Widget using the AnyWidget package to make it accessible within our Python code. AnyWidget makes this possible by defining a shared state between JavaScript and Python through traitlets and loading the JavaScript code as an ECMA script module.\n\nimport altair as alt\nimport pandas as pd\n\nimport anywidget\nimport traitlets\n\nAnyMidi is the name of our class that will fuction as a Jupyter Widget:\n\nclass AnyMidi(anywidget.AnyWidget):\n    _esm = \"index.js\"\n\n    enabled = traitlets.Bool(default_value=False).tag(sync=True)\n    target_name = traitlets.Unicode(default_value=None, allow_none=True).tag(sync=True)\n    inputs = traitlets.List(allow_none=True).tag(sync=True)\n    noteon = traitlets.Dict(allow_none=True).tag(sync=True)\n    noteons = traitlets.List(allow_none=True).tag(sync=True)\n\nanym = AnyMidi()\n\nUsing the _esm parameter we refer to our JavaScript code as an ECMAScript module. Next, we define multipe traitlets. This are classes that functions as interchange objects between Python and JavaScript.\nOnce these variables are set within JavaScript, the corresponding variable in Python is updated. And vice-versa, if this variable is changed within Python, the variable is updated in JavaScript.\nOnce we call anym, it will initiate our Jupyter Widget and executes our JavaScript code. The code will enable the WebMidi.js package and collect information on available inputs.\n\nanym\n\n\n\n\n\n\nanym.enabled\n\nTrue\n\n\n\nanym.inputs\n\n[{'name': 'USB-MIDI',\n  'manufacturer': 'Kawai Musical Instruments Mfg. Co., Ltd'}]\n\n\nBy default it add a listener to the first input device it detects target_name. The listener will update once a note on the musical instrument is played.\n\nanym.target_name\n\n'USB-MIDI'\n\n\nSo if I play a note on the piano, information on of this note is captured and stored in the noteon attribute\n\nanym.noteon\n\n{'id': 'D7',\n 'attack': 0.5590551181102362,\n 'ts': 718244,\n 'name': 'D',\n 'octave': 7,\n 'accidental': 'dW5kZWZpbmVk'}\n\n\nThe noteon attribute only provides information on the last played note, I also have configured another attribute named noteons. This attribute stores the last 100 played notes. This is a list that is empty by initiation and then upon playing the piano growing to a list of 100 elements and after that stays at a length of 100. The new notes are added and the oldest notes are removed using shifting.\n\nanym.noteons[0:3]\n\n[{'id': 'C4',\n  'attack': 0.4015748031496063,\n  'ts': 440034,\n  'name': 'C',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'},\n {'id': 'D4',\n  'attack': 0.49606299212598426,\n  'ts': 449725,\n  'name': 'D',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'},\n {'id': 'E4',\n  'attack': 0.3543307086614173,\n  'ts': 450594,\n  'name': 'E',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'}]\n\n\nNow that we have configured some traitlets that updates once I play the piano we can connect the stream to a JupyterChart class.\nWe define the following Vega-Altair specification with an empty DataFrame as input source:\n\ndf = pd.DataFrame.from_records([])\n\nbar_chart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('id:N'),\n    y='count():O',\n    color='count():O'\n)\n\nThis is a bar chart with on the x-encoding channel the field id, see anym.noteons above and observe that this refers to the field representing the tone identifier of the piano key. The y-encoding channel and color-encoding channel represent the count of the tone played.\nAs the input DataFrame is still empty the chart will look as follows:\n\nbar_chart\n\n\n\n\n\n\n\nAs we like to connect our piano stream to the chart, we need to know the name identifier of our dataset within the Altair specification. We extract the name as follows:\n\ndata_name = bar_chart.to_dict()['data']['name']\ndata_name\n\n'data-4f53cda18c2baa0c0354bb5f9a3ecbe5'\n\n\nThis is a hashed representation of the dataset upon initiating of the Altair specification. So even if I run the cell of bar_chart again, it will not change the identifier of our dataset within the Altair specification.\nTo update this dataset within the bar_chart to the piano stream I need to define it as a altair.JupyterChart. This makes it possible to update the chart after it is displayed.\n\njchart = alt.JupyterChart(bar_chart)\n\nNext up is the defition of a function that is called when there is a change observed for the anym.noteons attribute.\nSo this function is called every time a new piano key is pressed and the tone is added to the list of anym.noteons. The function change_noteons takes the anym.noteons and replaces the data variable defined within the jchart object.\n\ndef change_noteons(change):\n    df = pd.DataFrame.from_records(anym.noteons)\n    jchart._py_to_js_updates = [{\n        \"namespace\": \"data\",\n        \"scope\": [],\n        \"name\": data_name,\n        \"value\": df.to_dict(\"records\")\n    }]\n\nanym.observe(change_noteons, \"noteons\")\n\nDone! Lets visualise our jchart visualisation and observe that the visualisation is updated when playing the piano.\n\njchart\n\n\n\n\n\nAwesome. That is fun. Before we continue. I forgot to explain one part. In our AnyMidi class definition is the line _esm = \"index.js\", this is in fact a referral to a file containing JavaScript code. For a better understanding I also will briefly go through this file. Some elements I will skip.\nThe file starts with the following\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\nThis is the import definition of the WebMidi JavaScript package that we use as an API to our connected piano using the MIDI protocol.\nThe other part that is important is the following:\nexport async function render({ model, el }) {\n    ...\n}\nThis defines a function with two objects. The model object and the el object. The model object makes it possible to store/set JavaScript variables that are approachable within Python using the traitlets objects.\nFor example the following code collects the different connected MIDI input devices and stores this in a inputsDict constant. Afterward this inputsDict dictionary is set on the inputs trait. We have to explicitly save the changes into model.\nconst inputsDict = WebMidi.inputs.map(input =&gt; ({\n    name: input.name,\n    manufacturer: input.manufacturer\n}));\n\nmodel.set(\"inputs\", inputsDict);\nmodel.save_changes();\nRemember the Python traitlet that synchronizes this data:\ninputs = traitlets.List(allow_none=True).tag(sync=True)\nThe following part is an example how the inpterplay between Python and JavaScript happens:\nBy default, the anym.target_name refers to the first detected name of the available inputs. But if you have multiple MIDI devices conncted you might want to switch the listener to a device of choice (I only have one device connected, so I cannot test if this actually works).\nSwitching is as simple as:\nanym.target_name = 'MY-OTHER-MIDI-DEVICE'\nWe listen to listen for changes of the target_name. This is done as follows:\nmodel.on(\"change:target_name\", () =&gt; {\n    console.log('Target name changed');\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        registerListener(newTarget);\n    } \n});\nIf a change is detected in the target_name the JavaScript code will execute a function. In this function the newTarget is defined by getting the new target_name (const newTarget = model.get(\"target_name\") and then a new listener is registered to this newTarget.\nIf an error occurs in the JavaScript side of things we like to tunnel back this to our Python notebook. We use the el element for this. For example to define an innerHTML property that pipes back the ${error.message}:\nconst showError = error =&gt; {\n    el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n        &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n        &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n        &lt;/div&gt;`;\n};\nThe full index.js code can be seen by:\n\n\nClicking me\n\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\n\nlet activeInput = null;\n\nexport async function render({ model, el }) {\n    const showError = error =&gt; {\n        el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n            &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n            &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const showSuccess = () =&gt; {\n        el.innerHTML = `&lt;div style=\"color:green;\"&gt;\n            &lt;p&gt;WebMidi enabled!&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const collectInputsWhenEnabled = async () =&gt; {\n        try {\n            await WebMidi.enable();\n            if (WebMidi.enabled) {\n                console.log(\"WebMidi is enabled\");\n                console.log(WebMidi);\n\n                const inputsDict = WebMidi.inputs.map(input =&gt; ({\n                    name: input.name,\n                    manufacturer: input.manufacturer\n                }));\n                console.log(inputsDict);\n\n                model.set(\"inputs\", inputsDict);\n                model.save_changes();\n                console.log(\"WebMidi input saved in model\");\n\n                // Set target_name if it's not set already\n                if (!model.get(\"target_name\")) {\n                    const firstInput = WebMidi.inputs[0];\n                    if (firstInput) {\n                        model.set(\"target_name\", firstInput.name);\n                        model.save_changes();\n                    }\n                }\n            } else {\n                console.log(\"WebMidi is not yet seen as enabled\");\n                setTimeout(collectInputsWhenEnabled, 1000); \n            }\n        } catch (error) {\n            showError(error);\n        }\n    };\n\n    const registerListener = newTarget =&gt; {\n        // Remove listener from previous input, if exists\n        if (activeInput) {\n            console.log('Removing current active listener');\n            activeInput.removeListener();\n        }\n\n        activeInput = WebMidi.getInputByName(newTarget);\n        if (!activeInput) {\n            console.log('Setting none values');\n            // If activeInput is undefined, set noteons and noteon to empty or null\n            model.set(\"noteons\", []);\n            model.set(\"noteon\", null);\n            model.save_changes();\n            return;\n        }\n\n        const noteonsArray = [];\n        activeInput.addListener(\"noteon\", e =&gt; {\n            const noteonDict = {\n                id: e.note.identifier, \n                attack: e.note.attack,\n                ts: e.timestamp,\n                name: e.note.name,\n                octave: e.note.octave,\n                accidental: btoa(e.note.accidental)\n            };\n            console.log(noteonDict);\n            noteonsArray.push(noteonDict);\n            while (noteonsArray.length &gt; 100) {\n                noteonsArray.shift();\n            }\n            model.set(\"noteons\", noteonsArray);\n            model.set(\"noteon\", noteonDict);\n            model.save_changes();\n        });\n    };\n\n    try {\n        await collectInputsWhenEnabled();\n        model.set(\"enabled\", WebMidi.enabled);\n        model.save_changes();\n        showSuccess();\n    } catch (error) {\n        showError(error);\n    }\n\n    // Listen for changes to target_name and update the listener accordingly\n    model.on(\"change:target_name\", () =&gt; {\n        console.log('Target name changed');\n        const newTarget = model.get(\"target_name\") || null;\n        if (newTarget !== null) {\n            registerListener(newTarget);\n        } \n    });\n\n    // If target_name is already set, register the listener\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        console.log('Target name already set');\n        registerListener(newTarget);\n    } \n}\n\nLater more!"
  },
  {
    "objectID": "posts/2024-01-22-stream-piano-midi-to-altair/index.html#stream-data-from-a-piano-to-a-vega-altair-chart-using-midi",
    "href": "posts/2024-01-22-stream-piano-midi-to-altair/index.html#stream-data-from-a-piano-to-a-vega-altair-chart-using-midi",
    "title": "Stream data from a piano to a Vega-Altair chart using MIDI",
    "section": "",
    "text": "I came to realise that playing a piano is a great example of streaming data. And since there is currently much activity around the JupyterChart object within Vega-Altair. Let’s see how far we can bring this combination into practice.\nLets start with a video of the final result\n\n\nWhoop! Whoop. It actually works. Lets break down what we see in the video.\n\nWe see a piano and a laptop.\nOnce I start playing the piano a histogram appears and updates.\n\nThe digital piano (kawai CA78) is connected with the laptop using an USB cable that streams musical information using the MIDI protocol.\nThe laptop presents a notebook within a JupyterLab environment. Within the notebook the video starts with an empty Vega-Altair bar chart. The chart is set-up to listen to the incoming stream of the musical information by the piano and once I start touching notes a histogram appears.\nOn the x-encoding channel we see all touched independent notes and on both the y-encoding channel and color-encoding channel we see the count() of the touched notes. This type of histogram is also known as a pianogram.\n\n\nThe basis of the code is a Jupyter notebook written in Python. We listen to the incoming musical information using WEBMIDI.js. This is a package that performs as a Web MIDI API allowing a web page to interact with MIDI musical instruments. Since WEBMIDI.js is JavaScript we develop a custom Jupyter Widget using the AnyWidget package to make it accessible within our Python code. AnyWidget makes this possible by defining a shared state between JavaScript and Python through traitlets and loading the JavaScript code as an ECMA script module.\n\nimport altair as alt\nimport pandas as pd\n\nimport anywidget\nimport traitlets\n\nAnyMidi is the name of our class that will fuction as a Jupyter Widget:\n\nclass AnyMidi(anywidget.AnyWidget):\n    _esm = \"index.js\"\n\n    enabled = traitlets.Bool(default_value=False).tag(sync=True)\n    target_name = traitlets.Unicode(default_value=None, allow_none=True).tag(sync=True)\n    inputs = traitlets.List(allow_none=True).tag(sync=True)\n    noteon = traitlets.Dict(allow_none=True).tag(sync=True)\n    noteons = traitlets.List(allow_none=True).tag(sync=True)\n\nanym = AnyMidi()\n\nUsing the _esm parameter we refer to our JavaScript code as an ECMAScript module. Next, we define multipe traitlets. This are classes that functions as interchange objects between Python and JavaScript.\nOnce these variables are set within JavaScript, the corresponding variable in Python is updated. And vice-versa, if this variable is changed within Python, the variable is updated in JavaScript.\nOnce we call anym, it will initiate our Jupyter Widget and executes our JavaScript code. The code will enable the WebMidi.js package and collect information on available inputs.\n\nanym\n\n\n\n\n\n\nanym.enabled\n\nTrue\n\n\n\nanym.inputs\n\n[{'name': 'USB-MIDI',\n  'manufacturer': 'Kawai Musical Instruments Mfg. Co., Ltd'}]\n\n\nBy default it add a listener to the first input device it detects target_name. The listener will update once a note on the musical instrument is played.\n\nanym.target_name\n\n'USB-MIDI'\n\n\nSo if I play a note on the piano, information on of this note is captured and stored in the noteon attribute\n\nanym.noteon\n\n{'id': 'D7',\n 'attack': 0.5590551181102362,\n 'ts': 718244,\n 'name': 'D',\n 'octave': 7,\n 'accidental': 'dW5kZWZpbmVk'}\n\n\nThe noteon attribute only provides information on the last played note, I also have configured another attribute named noteons. This attribute stores the last 100 played notes. This is a list that is empty by initiation and then upon playing the piano growing to a list of 100 elements and after that stays at a length of 100. The new notes are added and the oldest notes are removed using shifting.\n\nanym.noteons[0:3]\n\n[{'id': 'C4',\n  'attack': 0.4015748031496063,\n  'ts': 440034,\n  'name': 'C',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'},\n {'id': 'D4',\n  'attack': 0.49606299212598426,\n  'ts': 449725,\n  'name': 'D',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'},\n {'id': 'E4',\n  'attack': 0.3543307086614173,\n  'ts': 450594,\n  'name': 'E',\n  'octave': 4,\n  'accidental': 'dW5kZWZpbmVk'}]\n\n\nNow that we have configured some traitlets that updates once I play the piano we can connect the stream to a JupyterChart class.\nWe define the following Vega-Altair specification with an empty DataFrame as input source:\n\ndf = pd.DataFrame.from_records([])\n\nbar_chart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('id:N'),\n    y='count():O',\n    color='count():O'\n)\n\nThis is a bar chart with on the x-encoding channel the field id, see anym.noteons above and observe that this refers to the field representing the tone identifier of the piano key. The y-encoding channel and color-encoding channel represent the count of the tone played.\nAs the input DataFrame is still empty the chart will look as follows:\n\nbar_chart\n\n\n\n\n\n\n\nAs we like to connect our piano stream to the chart, we need to know the name identifier of our dataset within the Altair specification. We extract the name as follows:\n\ndata_name = bar_chart.to_dict()['data']['name']\ndata_name\n\n'data-4f53cda18c2baa0c0354bb5f9a3ecbe5'\n\n\nThis is a hashed representation of the dataset upon initiating of the Altair specification. So even if I run the cell of bar_chart again, it will not change the identifier of our dataset within the Altair specification.\nTo update this dataset within the bar_chart to the piano stream I need to define it as a altair.JupyterChart. This makes it possible to update the chart after it is displayed.\n\njchart = alt.JupyterChart(bar_chart)\n\nNext up is the defition of a function that is called when there is a change observed for the anym.noteons attribute.\nSo this function is called every time a new piano key is pressed and the tone is added to the list of anym.noteons. The function change_noteons takes the anym.noteons and replaces the data variable defined within the jchart object.\n\ndef change_noteons(change):\n    df = pd.DataFrame.from_records(anym.noteons)\n    jchart._py_to_js_updates = [{\n        \"namespace\": \"data\",\n        \"scope\": [],\n        \"name\": data_name,\n        \"value\": df.to_dict(\"records\")\n    }]\n\nanym.observe(change_noteons, \"noteons\")\n\nDone! Lets visualise our jchart visualisation and observe that the visualisation is updated when playing the piano.\n\njchart\n\n\n\n\n\nAwesome. That is fun. Before we continue. I forgot to explain one part. In our AnyMidi class definition is the line _esm = \"index.js\", this is in fact a referral to a file containing JavaScript code. For a better understanding I also will briefly go through this file. Some elements I will skip.\nThe file starts with the following\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\nThis is the import definition of the WebMidi JavaScript package that we use as an API to our connected piano using the MIDI protocol.\nThe other part that is important is the following:\nexport async function render({ model, el }) {\n    ...\n}\nThis defines a function with two objects. The model object and the el object. The model object makes it possible to store/set JavaScript variables that are approachable within Python using the traitlets objects.\nFor example the following code collects the different connected MIDI input devices and stores this in a inputsDict constant. Afterward this inputsDict dictionary is set on the inputs trait. We have to explicitly save the changes into model.\nconst inputsDict = WebMidi.inputs.map(input =&gt; ({\n    name: input.name,\n    manufacturer: input.manufacturer\n}));\n\nmodel.set(\"inputs\", inputsDict);\nmodel.save_changes();\nRemember the Python traitlet that synchronizes this data:\ninputs = traitlets.List(allow_none=True).tag(sync=True)\nThe following part is an example how the inpterplay between Python and JavaScript happens:\nBy default, the anym.target_name refers to the first detected name of the available inputs. But if you have multiple MIDI devices conncted you might want to switch the listener to a device of choice (I only have one device connected, so I cannot test if this actually works).\nSwitching is as simple as:\nanym.target_name = 'MY-OTHER-MIDI-DEVICE'\nWe listen to listen for changes of the target_name. This is done as follows:\nmodel.on(\"change:target_name\", () =&gt; {\n    console.log('Target name changed');\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        registerListener(newTarget);\n    } \n});\nIf a change is detected in the target_name the JavaScript code will execute a function. In this function the newTarget is defined by getting the new target_name (const newTarget = model.get(\"target_name\") and then a new listener is registered to this newTarget.\nIf an error occurs in the JavaScript side of things we like to tunnel back this to our Python notebook. We use the el element for this. For example to define an innerHTML property that pipes back the ${error.message}:\nconst showError = error =&gt; {\n    el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n        &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n        &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n        &lt;/div&gt;`;\n};\nThe full index.js code can be seen by:\n\n\nClicking me\n\nimport { WebMidi } from \"https://esm.sh/webmidi@3.1.8\";\n\nlet activeInput = null;\n\nexport async function render({ model, el }) {\n    const showError = error =&gt; {\n        el.innerHTML = `&lt;div style=\"color:red;\"&gt;\n            &lt;p&gt;JavaScript Error: ${error.message}&lt;/p&gt;\n            &lt;p&gt;See the JavaScript console for the full traceback.&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const showSuccess = () =&gt; {\n        el.innerHTML = `&lt;div style=\"color:green;\"&gt;\n            &lt;p&gt;WebMidi enabled!&lt;/p&gt;\n            &lt;/div&gt;`;\n    };\n\n    const collectInputsWhenEnabled = async () =&gt; {\n        try {\n            await WebMidi.enable();\n            if (WebMidi.enabled) {\n                console.log(\"WebMidi is enabled\");\n                console.log(WebMidi);\n\n                const inputsDict = WebMidi.inputs.map(input =&gt; ({\n                    name: input.name,\n                    manufacturer: input.manufacturer\n                }));\n                console.log(inputsDict);\n\n                model.set(\"inputs\", inputsDict);\n                model.save_changes();\n                console.log(\"WebMidi input saved in model\");\n\n                // Set target_name if it's not set already\n                if (!model.get(\"target_name\")) {\n                    const firstInput = WebMidi.inputs[0];\n                    if (firstInput) {\n                        model.set(\"target_name\", firstInput.name);\n                        model.save_changes();\n                    }\n                }\n            } else {\n                console.log(\"WebMidi is not yet seen as enabled\");\n                setTimeout(collectInputsWhenEnabled, 1000); \n            }\n        } catch (error) {\n            showError(error);\n        }\n    };\n\n    const registerListener = newTarget =&gt; {\n        // Remove listener from previous input, if exists\n        if (activeInput) {\n            console.log('Removing current active listener');\n            activeInput.removeListener();\n        }\n\n        activeInput = WebMidi.getInputByName(newTarget);\n        if (!activeInput) {\n            console.log('Setting none values');\n            // If activeInput is undefined, set noteons and noteon to empty or null\n            model.set(\"noteons\", []);\n            model.set(\"noteon\", null);\n            model.save_changes();\n            return;\n        }\n\n        const noteonsArray = [];\n        activeInput.addListener(\"noteon\", e =&gt; {\n            const noteonDict = {\n                id: e.note.identifier, \n                attack: e.note.attack,\n                ts: e.timestamp,\n                name: e.note.name,\n                octave: e.note.octave,\n                accidental: btoa(e.note.accidental)\n            };\n            console.log(noteonDict);\n            noteonsArray.push(noteonDict);\n            while (noteonsArray.length &gt; 100) {\n                noteonsArray.shift();\n            }\n            model.set(\"noteons\", noteonsArray);\n            model.set(\"noteon\", noteonDict);\n            model.save_changes();\n        });\n    };\n\n    try {\n        await collectInputsWhenEnabled();\n        model.set(\"enabled\", WebMidi.enabled);\n        model.save_changes();\n        showSuccess();\n    } catch (error) {\n        showError(error);\n    }\n\n    // Listen for changes to target_name and update the listener accordingly\n    model.on(\"change:target_name\", () =&gt; {\n        console.log('Target name changed');\n        const newTarget = model.get(\"target_name\") || null;\n        if (newTarget !== null) {\n            registerListener(newTarget);\n        } \n    });\n\n    // If target_name is already set, register the listener\n    const newTarget = model.get(\"target_name\") || null;\n    if (newTarget !== null) {\n        console.log('Target name already set');\n        registerListener(newTarget);\n    } \n}\n\nLater more!"
  }
]