[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mattijn.github.io",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nTristan O‚ÄôMalley\n\n\n\n\n\n\n\n\n\n\n\n\nVerken de diversiteit van Nederlandse gemeenten\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nMattijn van Hoek\n\n\n\n\n\n\n\n\n\n\n\n\nEngaging geovisualisations with Vega-Altair\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2023\n\n\nMattijn van Hoek\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html",
    "href": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te cre√´ren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda‚Äôs en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "href": "posts/2024-01-26-CBS-nationaliteiten/2024-01-26 CBS Nationaliteit.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te cre√´ren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda‚Äôs en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "href": "posts/2024-01-26-CBS-nationaliteiten/index.html",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te cre√´ren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda‚Äôs en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2024-01-26-CBS-nationaliteiten/index.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "href": "posts/2024-01-26-CBS-nationaliteiten/index.html#verken-de-diversiteit-van-nederlandse-gemeenten",
    "title": "Verken de diversiteit van Nederlandse gemeenten",
    "section": "",
    "text": "In dit artikel duiken we diep in de gegevens van Nederlandse gemeenten op basis van geboortelanden, van de ruwe data tot een boeiende interactieve visualisatie.\nMet behulp van de cbsodata-bibliotheek verzamelen we gedetailleerde bevolkingsgegevens per nationaliteit voor het jaar 2023. Dankzij slimme filtering en coding identificeren we vervolgens per gemeente de twee meest voorkomende Nationaliteiten.\n\n\nCode\nimport cbsodata\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport topojson as tp\n\n\n# list of nationaliteit codes\nnatcodes_landen = ['NAT9278','NAT9281','NAT9292','NAT9300','NAT9301','NAT9303','NAT9307','NAT9310','NAT9322','NAT9324','NAT9326','NAT9330','NAT9332','NAT9336','NAT9338','NAT9345','NAT9346','NAT9348','NAT9349','NAT9350','NAT9351','NAT9353','NAT9356','NAT9357','NAT9368','NAT9372','NAT9377','NAT9387','NAT9403','NAT9406','NAT9409','NAT9410','NAT9415','NAT9416','NAT9417','NAT9418','NAT9436','NAT9440','NAT9442','NAT9444','NAT9448','NAT9454','NAT9458','NAT9470','NAT9473','NAT9480']\nfilter_natcodes = ''.join([f\"(Nationaliteit eq '{natcode}') or \" for natcode in natcodes_landen]).rstrip(' or ')\nfilter_natcodes\n\n# collect data for selection of nationalities\ndf = pd.DataFrame(cbsodata.get_data(\n    table_id='85644NED', \n    select=['Bevolking_1', 'Nationaliteit', 'RegioS'], \n    filters=f\"((Geslacht eq 'T001038')) and ((Leeftijd eq '10000')) and ({filter_natcodes}) and ((Perioden eq '2023JJ00')) and ((substringof('GM',RegioS)))\"\n))\ndf = df.dropna(subset='Bevolking_1', how='any')\n\n# get 2nd largest groups for eacht gemeente\ndf_max_2per_gemeente = df.loc[df.groupby('RegioS')['Bevolking_1'].nlargest(2).reset_index(level=0, drop=True).index]\n\n# split in two dataframes\ndf_pop_one = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].head(1).index]\ndf_pop_two = df.loc[df_max_2per_gemeente.groupby('RegioS')['Bevolking_1'].tail(1).index]\n\n# load IDs of each gemeente\ndf_regioscodes = pd.read_csv('RegioSCodes.csv', sep=';')\ndf_gemcodes = df_regioscodes[df_regioscodes.Identifier.str.startswith('GM')]\n\n# combine with our data from CBS\ndf_pop_one_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_one, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\ndf_pop_two_gemeente_id = pd.merge(df_gemcodes[['Identifier', 'Title']], df_pop_two, right_on='RegioS', left_on='Title', how='left').drop('Title', axis=1)\n\n# load geometry of each gemeente\ngeodata_url = 'gemeenten_2023.geo.json'\ngemeentegrenzen = gpd.read_file(geodata_url, driver='GeoJSON')\ngemeentegrenzen = tp.Topology(gemeentegrenzen, toposimplify=1000, topoquantize=1000).to_gdf()\n\n# connect CBS-data to geometroe wit gemcodes\ndf_pop_one_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_one_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\ndf_pop_two_gemeente_id_geom = pd.merge(gemeentegrenzen[['statcode', 'statnaam', 'geometry']], df_pop_two_gemeente_id, right_on='Identifier', left_on='statcode', how='left').drop(['RegioS', 'Identifier', 'statcode'], axis=1)\n\n# rename columns\ndf_pop_one_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\ndf_pop_two_gemeente_id_geom.columns = ['Gemeente', 'geometry', 'Aantal', 'Nationaliteit']\n\n\nMet Altair zijn we in staat om levendige kaarten en staafdiagrammen te cre√´ren. Kleurrijke details, vormen en interactieve elementen maken de data niet alleen toegankelijk, maar ook boeiend. Verken de gegevens op jouw eigen tempo met legenda‚Äôs en selectiemogelijkheden.\n\n\nCode\n# build chart\nselection = alt.selection_point(fields=['Nationaliteit'], bind='legend', empty=True)\nfill_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#ad494a', '#8c6d31']\n\nleft_geom = alt.Chart(df_pop_one_gemeente_id_geom, title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).legend(orient='bottom', columns=9).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nleft_bar = alt.Chart(\n    df_pop_one_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='1e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_bar = alt.Chart(\n    df_pop_two_gemeente_id_geom, \n    title=alt.Title(text=' ', subtitle='2e meestvoorkomende nationaliteit')\n).mark_bar(tooltip=True, stroke='black').encode(\n    x=alt.X('count()').scale(reverse=True).title('Aantal gemeenten'),\n    y=alt.Y('Nationaliteit').sort('-x').axis(orient='right').title(None), \n    fill=alt.Fill('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n)\n\nright_geom = alt.Chart(df_pop_two_gemeente_id_geom, title=alt.Title(text=' ',subtitle='2e meestvoorkomende nationaliteit')).mark_geoshape(tooltip=True, stroke='black').encode(\n    fill=alt.Color('Nationaliteit').scale(range=fill_colors).sort(field='Aantal', op='count', order='descending'),\n    strokeWidth=alt.condition(selection, alt.value(0.4), alt.value(0)),   \n    tooltip=[alt.Tooltip('Gemeente'), alt.Tooltip('Nationaliteit'), alt.Tooltip('Aantal')],\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))    \n).project(type='identity', reflectY=True)\n\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.hconcat(\n    left_bar.properties(height=400, width=100),\n    left_geom.properties(height=400, width=400),\n    right_geom.properties(height=400, width=400),\n    right_bar.properties(height=400, width=100)\n).properties(\n    title=alt.TitleParams(text='Nederlandse gemeenten op basis van nationaliteit.', subtitle='CBS, PDOK (2023)', anchor='start')\n).configure_legend(\n    titleFontSize=15,\n    labelFontSize=15,\n    labelLimit=200\n).configure_title(\n    fontSize=15,\n    subtitleFontSize=15\n).add_params(\n    selection\n)\n\n\n\n\n\n\nDe kaart is hoverbaar en de legenda items zijn klikbaar. Ergens in de legenda niet op een naam klikken maakt de selectie ongedaan.\n\n\nDeze analyse onthult inzichten in de diversiteit van nationaliteiten binnen Nederlandse gemeenten. De interactieve visualisatie nodigt je uit om verder te ontdekken, waardoor je een levendig beeld krijgt van de diverse culturen in Nederland.\nKlaar om de diversiteit binnen Nederlandse gemeenten te verkennen? Ontdek de diversiteit van de Nederlandse samenleving per gemeente.\n\n\nCode\noptions = df.RegioS.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Gemeente: '\n)\nselection = alt.selection_point(\n    fields=['RegioS'],\n    bind=input_dropdown,\n    empty=False,\n    value='Amsterdam'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('Nationaliteit').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).properties(\n    title=alt.TitleParams(text='Nationaliteiten per gemeente op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere gemeente te selecteren.\n\n\nEn om het helemaal af te maken, de gemeenten gesorteerd per nationaliteit.\n\n\nCode\noptions = df.Nationaliteit.unique().tolist()\ninput_dropdown = alt.binding_select(\n    options=options,\n    name='Nationaliteit: '\n)\nselection = alt.selection_point(\n    fields=['Nationaliteit'],\n    bind=input_dropdown,\n    empty=False,\n    value='Pools'\n)\n\nalt.data_transformers.disable_max_rows()\nalt.renderers.set_embed_options(actions=False, renderer='svg')\nalt.Chart(df, width=1325).mark_bar(tooltip=True, stroke='black', opacity=1).encode(\n    y=alt.Y('Bevolking_1:Q').title('Aantal in gemeente'),\n    x=alt.X('RegioS').sort('-y').title(None),\n    fill=alt.Fill('Bevolking_1')\n        .legend(title='Aantal in gemeente', orient='top')\n        .title('Aantal in gemeente')\n        .scale(domain=[0, 75000], range=['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF', '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1', '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD', '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388', '#805770', '#684957', '#46353A'], type='pow', exponent=0.2, interpolate='rgb',)\n).add_params(\n    selection\n).transform_filter(\n    selection\n).transform_window(\n    rank='rank(RegioS)',\n    sort=[alt.SortField('Bevolking_1', order='descending')]\n).transform_filter(\n    (alt.datum.rank &lt; 30)\n).properties(\n    title=alt.TitleParams(text='Gemeenten per nationaliteit op basis van geboorteland buiten Nederland.', subtitle='CBS, PDOK (2023)', anchor='start')\n)\n\n\n\n\n\n\nDe staafdiagram is hoverbaar en het selectie menu biedt mogelijkheden om een andere nationaliteit te selecteren."
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\n\n\nEncode spatial data as topology in Python! üåç https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivi√®re (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel √ñstblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair‚Äôs API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet‚Äôs load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark‚Äôs color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet‚Äôs load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  },
  {
    "objectID": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "href": "posts/2023-03-07-talk-geopython-2023/index.html#engaging-geovisualisations-with-vega-altair",
    "title": "Engaging geovisualisations with Vega-Altair",
    "section": "",
    "text": "Vega-Altair is a powerful toolkit for creating interactive and engaging geovisualisations in Python.\nLets talk about it.\nBy Mattijn van Hoek\n\nPhD on Drought Monitoring from Space & MSc in Geographical Information Management\nSenior consultant Product & Services @ HKV Consultants, The Netherlands\nKnowledge entrepreneurs in flood risk and water resources management\n\n\n\nEncode spatial data as topology in Python! üåç https://mattijn.github.io/topojson\npip/conda install topojson\n\n\nVegaFusion: Serverside Scaling for Vega, Started by Jon Mease in 2021\nVega-Altair: Declarative Visualization in Python. Started by Jake Vanderplas & Brian Granger in 2015\nVega-Lite: A Grammar of Interactive Graphics. Started by Arvind Satyanarayan, Kanit Wongsuphasawat, Dominik Moritz in 2014\nVega: A Visualization Grammar. Started by Jeffrey Heer and Arvind Satyanarayan in 2014\nD3: Data-Driven Documents, Started by Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky in 2011 | Philippe Rivi√®re (D3-Geo)\nFor Vega-Altair I also like to mention: Christopher Davis, Joel √ñstblom, Stefan Binder, Eitan Lees, Ben Welsh (and myself)\nNEW! website: https://altair-viz.github.io/\n\nVega-Altair is a declarative statistical visualization library for Python, based on Vega-Lite.\nWith Vega-Altair, you can spend more time understanding your data and its meaning. Altair‚Äôs API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar.\nThis elegant simplicity produces beautiful and effective visualizations with a minimal amount of code.\nMonthly PyPi downloads: 10.3M (comparison matplotlib 31.4M, plotly 7.7M)\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nMontly PyPi downloads of Vega-Altair have increased to 21.5M (comparison matplotlib 56.9M, plotly 12.7M).\n\n\n\nimport altair as alt\nfrom vega_datasets import data\nsource = data.cars()\n\nalt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon', \n    color='Origin',\n)\n\n\n\n\n\n\n\nOne of the unique features of Vega-Altair, inherited from Vega-Lite, is a declarative grammar of not just visualization, but also interaction.\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(source).mark_point().encode(\n    x='Horsepower', \n    y='Miles_per_Gallon',\n    color=alt.condition(brush, 'Origin', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(source).mark_bar().encode(\n    y='Origin', \n    color='Origin', \n    x='count(Origin)'\n).transform_filter(\n    brush\n)\n\n\npoints & bars\n\n\n\n\n\n\n\nVega-Altair works with many different geographical data formats, including geojson and topojson files and any data format that supports the geo interface protocol (.__geo_interface__)\nOften the most convenient input format is a GeoDataFrame.\nHere we load the Natural Earth dataset (50m_admin_0_countries)\n\nimport geopandas as gpd\ngdf_world = gpd.read_file(r'ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp')\ngdf_world = gdf_world[['ADMIN', 'POP_EST', 'geometry']]\ngdf_world.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n0\nZimbabwe\n14645468.0\nPOLYGON ((31.28789 -22.40205, 31.19727 -22.344...\n\n\n1\nZambia\n17861030.0\nPOLYGON ((30.39609 -15.64307, 30.25068 -15.643...\n\n\n2\nYemen\n29161922.0\nMULTIPOLYGON (((53.08564 16.64839, 52.58145 16...\n\n\n3\nVietnam\n96462106.0\nMULTIPOLYGON (((104.06396 10.39082, 104.08301 ...\n\n\n4\nVenezuela\n28515829.0\nMULTIPOLYGON (((-60.82119 9.13838, -60.94141 9...\n\n\n\n\n\n\n\n\n\n\nmark_geoshape represents an arbitrary shapes whose geometry is determined by specified spatial data. By default, Altair applies a default blue fill color and uses a default map projection (equalEarth).\n\nimport altair as alt\nalt.Chart(gdf_world).mark_geoshape()\n\n\n\n\n\n\n\nWe can customize the aesthetics of the mark properties (eg. fill) and define a custom map projection\n\nalt.Chart(gdf_world).mark_geoshape(fill='lightgrey').project(type='albers')\n\n\n\n\n\n\n\n\n\n\nMultiple approaches can be used to focus on specific regions of your spatial data.\nHere we load an utility fuction to zoom by a bounding box polygon\n\nfrom utils_geoconf_23 import *\n\npolygon_bbox = utils_extent(minx=1, miny=51, maxx=9, maxy=55)\npolygon_bbox\n\n{'type': 'Feature',\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[9, 55], [9, 51], [1, 51], [1, 55], [9, 55]]]},\n 'properties': {}}\n\n\nWe set our polygon_bbox to the fit parameter within the project property in combination with clip=True in the mark properties.\n\nalt.Chart(gdf_world).mark_geoshape(clip=True).project(fit=polygon_bbox)\n\n\n\n\n\n\n\nTo improve speed it is often better to clip your region of interest from your GeoDataFrame.\n\ngdf_roi = gdf_world.clip([1, 50.6, 9, 55.3])\ngdf_roi.head()\n\n\n\n\n\n\n\n\n\nADMIN\nPOP_EST\ngeometry\n\n\n\n\n160\nFrance\n67059887.0\nPOLYGON ((1.57076 50.60000, 1.57949 50.73926, ...\n\n\n96\nNetherlands\n17332850.0\nMULTIPOLYGON (((5.99395 50.75044, 5.89246 50.7...\n\n\n156\nGermany\n83132799.0\nMULTIPOLYGON (((5.85752 51.03013, 5.86836 51.0...\n\n\n217\nBelgium\n11484055.0\nPOLYGON ((2.52490 51.09712, 2.96016 51.26543, ...\n\n\n31\nUnited Kingdom\n66834405.0\nMULTIPOLYGON (((1.00000 51.80094, 1.00000 52.9...\n\n\n\n\n\n\n\n\n\n\n\nWe can use the color encoding channel to map the visual property of the ADMIN column.\n\nbase = alt.Chart(gdf_roi).mark_geoshape().project(type='mercator')\nbase.encode(color='ADMIN')\n\n\n\n\n\n\n\nThe data type Altair applies is automatically inferred from the GeoDataFrame. Here we concatenate two columns with different datatypes - | : horizontal concat charts\n\nbase.encode(color='ADMIN') | base.encode(color='POP_EST')\n\n\n\n\n\n\n\n\n\n\nLet‚Äôs load another dataset containing lines\n\ngdf_rivers_eu = gpd.read_file(\"https://dmws.hkvservices.nl/dataportal/data.asmx/read?database=vega&key=europe_rivers\")\ngdf_rivers_roi = gdf_rivers_eu.clip([1, 50.6, 9, 55.3])\ngdf_rivers_roi\n\n\n\n\n\n\n\n\n\nname_en\ngeometry\n\n\n\n\n29\nRhine\nLINESTRING (7.22201 50.60000, 7.20362 50.62161...\n\n\n52\nWaal\nLINESTRING (4.98536 51.82371, 4.72543 51.75666...\n\n\n43\nNederrijn\nLINESTRING (6.03863 51.87218, 5.92246 51.96055...\n\n\n24\nLek\nLINESTRING (5.33108 51.96298, 5.16132 51.99352...\n\n\n\n\n\n\n\n\nBy default Altair assumes for mark_geoshape that the mark‚Äôs color is used for the fill color instead of the stroke color. This means that if your source data contain (multi)lines, you will have to explicitly define the filled value as False.\n\nchart_rivers_roi = alt.Chart(gdf_rivers_roi).mark_geoshape(\n    filled=False, stroke='#0E80AC', strokeWidth=2\n)\n\nchart_rivers_roi\n\n\n\n\n\n\n\n\n\n\nLayered charts allow you to overlay two different charts on the same set of mark. Here we combine our country polygons and river lines.\n\n+ : layer charts\n\n\nchart_roi = alt.Chart(gdf_roi).mark_geoshape(\n    fill='lightgray', stroke='white', strokeWidth=0.5\n)\n\nchart_base = chart_roi + chart_rivers_roi\nchart_base\n\n\n\n\n\n\n\n\n\n\nLet‚Äôs load another dataset containing points\n\nutils_gdf_points\n\n\n\n\n\n\n\n\n\nlocation\ngeometry\n\n\n\n\n0\ndelfzijl\nPOINT (6.93000 53.34000)\n\n\n1\nharlingen\nPOINT (5.40000 53.18000)\n\n\n2\nhoekvanholland\nPOINT (4.06000 52.00000)\n\n\n3\nvlissingen\nPOINT (3.55000 51.44000)\n\n\n\n\n\n\n\n\nAnd combine to our chart_base\n\nchart_pts = alt.Chart(utils_gdf_points).mark_geoshape().encode(\n    fill='location'\n)\n\nchart_base + chart_pts\n\n\n\n\n\n\n\nIn combination with mark_text for labels\n\nutils_gdf_points[\"lon\"] = utils_gdf_points.geometry.x\nutils_gdf_points[\"lat\"] = utils_gdf_points.geometry.y\n\nchart_text = alt.Chart(utils_gdf_points).mark_text(\n    align='right', dy=-10\n).encode(\n    longitude=\"lon\", latitude=\"lat\", text=\"location\"\n)\n\nchart_base + chart_pts + chart_text\n\n\n\n\n\n\n\n\n\n\nSo far, the grammar of graphics. Lets continue with grammar of interactivity\n\nparam_hover_loc = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_loc = alt.selection_point(\n    fields=['location'], value='hoekvanholland'\n)\n\nAnd a defintion of the the condition how the interactivity should behave\n[(&lt;condition_hover&gt;, &lt;if_true&gt;), (&lt;condition_click&gt;, &lt;if_true&gt;)], &lt;if_false&gt;\n\ncond_strokeWidth = utils_condition(\n    [(param_hover_loc, 2), (param_click_loc, 3)], if_false=0\n)\ncond_stroke = utils_condition(\n    [(param_hover_loc, 'red'), (param_click_loc, 'cyan')], if_false=None\n)\n\nAnd define a conditon that response to both hover and click\n\nchart_locs = chart_pts.encode(\n    strokeWidth=cond_strokeWidth, stroke=cond_stroke\n).add_params(\n    param_hover_loc, param_click_loc\n)\n\nchart_geoshape = chart_base + chart_locs + chart_text\nchart_geoshape\n\n\n\n\n\n\n\n\n\n\nOften a map does not come alone, but is used in combination with another chart.\nHere we provide an example of an interactive visualization of a rose plot and a geographic map.\n\nutils_df_storms_rose_binned.head()\n\n\n\n\n\n\n\n\n\nsector\ncount\nmean_windspeed\nwind_dir\nlocation\n\n\n\n\n0\n0\n77\n23.228312\n0.0 - 22.5\nhoekvanholland\n\n\n1\n1\n53\n23.361321\n22.5 - 45.0\nhoekvanholland\n\n\n2\n2\n33\n23.001515\n45.0 - 67.5\nhoekvanholland\n\n\n3\n3\n32\n23.115000\n67.5 - 90.0\nhoekvanholland\n\n\n4\n4\n10\n22.976000\n90.0 - 112.5\nhoekvanholland\n\n\n\n\n\n\n\n\nWe will use an arc mark. Arcs are circular and defined by a center point plus angular and radial extents.\n\nalt.Chart(utils_df_storms_rose_binned).mark_arc(tooltip=True).encode(\n    theta=alt.Theta('wind_dir').sort(field='sector'),\n    radius=alt.Radius('count'),\n    fill='mean_windspeed'\n).transform_filter(\n    alt.datum.location == 'vlissingen'\n)\n\n\n\n\n\n\n\nWe define similar interactive selection parameters as we did to the locations.\n\nparam_hover_wind_dir = alt.selection_point(\n    on='mouseover', clear='mouseout'\n)\nparam_click_wind_dir = alt.selection_point(\n    fields=['wind_dir'], value='225.0 - 247.5'\n)\n\nOur utility function utils_chart_rose() adds context and interactivity to the rose\n\nchart_rose = utils_chart_rose(utils_df_storms_rose_binned, \n    param_hover_wind_dir, param_click_wind_dir, param_click_loc\n)\n\nchart_rose\n\n\n\n\n\n\n\nAnd we can combine it with our already defined chart_geoshape - | : horizontal concat charts\n\nchart_rose | chart_geoshape\n\n\n\n\n\n\n\nOK, lets finish it up with a some histgrams. First load the data\n\nprint('df shape:', utils_df_storms_hist_binned.shape)\nutils_df_storms_hist_binned.head()\n\ndf shape: (6464, 14)\n\n\n\n\n\n\n\n\n\n\nfase\nfase_end\nfase_count\nwind_dir\nlocation\nwindfase\nwindfase_end\nwindfase_count\nwindduur\nwindduur_end\nwindduur_count\nopzetduur\nopzetduur_end\nopzetduur_count\n\n\n\n\n0\n-5.0\n-4.8\n3.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n-4.6\n-4.4\n1.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2.6\n2.8\n6.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n1.0\n1.2\n12.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n1.6\n1.8\n7.0\n0.0 - 22.5\nhoekvanholland\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nWe apply a double selection filter. One selection based on the location and one selection on the wind direction.\n\nalt.data_transformers.disable_max_rows()\nchart_hist = utils_chart_hists(utils_df_storms_hist_binned, \n    param_click_wind_dir, param_click_loc\n)\n\nchart_hist\n\n\n\n\n\n\n\nCombine everything what we have prepared (& : vertical concat charts)\n\nchart_hist & (chart_rose | chart_geoshape)\n\n\n\n\n\n\n\nWe can publish these interactive vizualisations 1:1 as a simple website: - http://ai.hkvservices.nl/gp_gui\nTo be shared with our clients\nI consider the following a scoop\nStill imperative now, but how far can push things using the new alt.param() and alt.expr() in Altair v5?\n\n\n\n\n\n\nEDIT february 2024\n\n\n\nThe logic of the example that follows is now implemented within https://altair-viz.github.io/altair_tiles/intro.html.\n\n\n\nimport altair as alt\nfrom vega_datasets import data\n\nsource = alt.topo_feature(data.world_110m.url, \"countries\")\nosm_url, otm_url = ('https://tile.openstreetmap.org/', 'https://tile.opentopomap.org/')\nselect_urls = alt.binding_select(options=[osm_url, otm_url], name='select tile service')\nparam_urls = alt.param(bind=select_urls, value=osm_url)\nparam_tx = alt.param(expr=\"width / 2\")\nparam_ty = alt.param(expr=\"height / 2\")\nparam_base_tile_size = alt.param(value=256)\nrange_z = alt.binding_range(min=2, max=13, step=0.05, name=\"zoom level\")\nparam_z = alt.param(value=2.75, bind=range_z)\nrange_x = alt.binding_range(min=-180, max=180, step=0.05, name=\"rotate longitude\")\nparam_x = alt.param(value=-5.9025, bind=range_x)\nrange_y = alt.binding_range(min=-60, max=60, step=0.05, name=\"center latitude\")\nparam_y = alt.param(value=52.56, bind=range_y)\nparam_tile_url = alt.param(expr=f'{param_urls.name}')\nparam_zoom = alt.param(expr=f\"ceil({param_z.name})\")\nparam_tiles_count = alt.param(expr=f\"pow(2, {param_zoom.name})\")\nparam_tile_size = alt.param(\n    expr=f\"{param_base_tile_size.name} * pow(2, {param_z.name} - {param_zoom.name})\"\n)\n\n\nparam_base_point = alt.param(expr=f\"invert('projection', [0, 0])\")\nparam_dii = alt.param(\n    expr=f\"({param_base_point.name}[0] + 180) / 360 * {param_tiles_count.name}\"\n)\nparam_di = alt.param(expr=f\"floor({param_dii.name})\")\nparam_dx = alt.param(\n    expr=f\"round((floor({param_dii.name}) - {param_dii.name}) * {param_tile_size.name})\"\n)\nparam_djj = alt.param(\n    expr=f\"(1 - log(tan({param_base_point.name}[1] * PI / 180) + 1 / cos({param_base_point.name}[1] * PI / 180)) / PI) / 2 * {param_tiles_count.name}\"\n)\nparam_dj = alt.param(expr=f\"floor({param_djj.name})\")\nparam_dy = alt.param(\n    expr=f\"round((floor({param_djj.name})-{param_djj.name}) * {param_tile_size.name})\"\n)\ntile_list = alt.sequence(0, 4, as_=\"a\", name=\"tile_list\")\n\n\nimage_tiles = (\n    alt.Chart(tile_list)\n    .mark_image(\n        width=alt.expr(f\"{param_tile_size.name}\"),\n        height=alt.expr(f\"{param_tile_size.name}\"),\n        clip=True,\n    )\n    .transform_calculate(b=f\"sequence(0, 4)\")\n    .transform_flatten([\"b\"])\n    .transform_calculate(\n        url=f\"{param_tile_url.name} + {param_zoom.name} + '/' + (datum.a + {param_di.name} + {param_tiles_count.name}) % {param_tiles_count.name} + '/' + ((datum.b + {param_dj.name})) + '.png'\",\n        x=f\"(datum.a * {param_tile_size.name} + {param_dx.name}) + ({param_tile_size.name} / 2)\",\n        y=f\"(datum.b * {param_tile_size.name} + {param_dy.name}) + ({param_tile_size.name} / 2)\",\n    )\n    .encode(\n        x=alt.X(\"x:Q\").scale(None), y=alt.Y(\"y:Q\").scale(None), url=alt.Url(\"url:N\")\n    )\n)\n\n\ngeoshape_countries = (\n    alt.Chart(source, width=400, height=400)\n    .mark_geoshape(\n        stroke=\"orange\", \n        strokeWidth=2, \n        fillOpacity=0.1\n    )\n    .encode(fill=\"id:Q\")\n    .project(\n        type=\"mercator\",\n        scale=alt.expr(\n            f\"{param_base_tile_size.name} * pow(2, {param_z.name}) / (2 * PI)\"\n        ),\n        rotate=alt.expr(f\"[{param_x.name}, 0, 0]\"),\n        center=alt.expr(f\"[0, {param_y.name}]\"),\n        translate=alt.expr(f\"[{param_tx.name}, {param_ty.name}]\"),\n    )\n)\n\ntext_attrib = alt.Chart().mark_text(\n    text='(C) OpenStreetMap contributors',\n    dx=-85,\n    dy=-10\n).encode(\n    x=alt.value(alt.expr('width')), \n    y=alt.value(alt.expr('height'))\n)\n\n\nchart_inc_tiles = alt.layer(\n    image_tiles,\n    geoshape_countries,\n    text_attrib\n).add_params(\n    param_urls,\n    param_tile_url,\n    param_zoom,\n    param_tiles_count,\n    param_tile_size,\n    param_base_point,\n    param_dii,\n    param_di,\n    param_dx,\n    param_djj,\n    param_dj,\n    param_dy,\n    param_y,\n    param_x,\n    param_z,\n    param_tx,\n    param_ty,\n    param_base_tile_size,\n)\n\nhopefully one day possible through mark_geoshape(tiles=True)\n\nchart_inc_tiles\n\n\n\n\n\n\n\nWhat else will be new in Altair 5 (5.0.0rc1 released last week) - The primary change in this release of Altair is the introduction of parameters. There are two types of parameters, selection parameters and variable parameters.\n\nSupport for method-based-syntax:\n\n\nBefore only argument-based syntax was possible:\n\nx=alt.X('Horsepower', axis=alt.Axis(tickMinStep=50))\n\nNow also method-based syntax:\n\nx=alt.X('Horsepower').axis(tickMinStep=50)\n\nNative Support for DataFrame Interchange Protocol Support (experimental, through pyarrow)\n\nalt.Chart(any_df)\n\n\nExtensive type hinting\n\n\n\nnew xOffset and yOffset encoding channels\n\n\n\nReplaced altair_saver with vl-convert-python for saving to png/svg (pip-installable, no need for a headless browser anymore)\nOrdered pandas categorical data are now automatically encoded as sorted ordinal data\nselection_interval() support for mark_geoshape()\n\n\n\nDocs for spatial data and mark_geoshape options:\n\nhttps://altair-viz.github.io/user_guide/data.html#spatial-data\nhttps://altair-viz.github.io/user_guide/marks/geoshape.html"
  }
]